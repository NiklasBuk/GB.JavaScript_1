<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>
</head>
<body>
   <script>
// 1




// 2

// так и не разобрался окончательно с данной задачей, по какой-то причине интерпретатор не заходит в проверку условия и не определяет переменную, поднимая undefined. Видимо, в объекте window есть строка 'a', что дает true, но !true = false, поэтому условие не выполняется и не определяет переменную a
if (!("a" in window)) {
   var a = 1;
}
alert(a);

// undefined. Функция a находится в функциональном выражении b, т.е. она не является декларированной функцией, а является значением переменной b, обратиться к ней без поднятия переменной, которой она присвоена, мы не можем
var b = function a(x) {
   x && a(--x);
};
alert(a);

// объявляем функцию а, далее объявляем переменную с тем же именем. Объявление функции имеет больший приоритет над объявлением переменной, если переменная не определена, поэтому при поднятии значения а будет выдана в модальном окне функция а в виде строки
function a(x) {
   return x * 2;
}
var a;
alert(a);

// в модальном окне будет выдано значение 10. Объявлена функция b и вызывается с параметрами 1,2,3, при отработке тела функции идет обращение к ее аргументу 2 из псевдомассива параметров, т.е. а и ему присваивается новое значение 10, а потом поднимается эта переменная
function b(x, y, a) {
   arguments[2] = 10;
   alert(a);
}
b(1, 2, 3);

// вызываем объявленную функцию а, в теле которой есть команда поднятия этой функции, но при вызове идет обращение к свойству оператором call с параметром null, то есть без значений. Таким образом функция не обращается ни к одному значению и выдает объект window
function a() {
   alert(this);
}
a.call(null);

   </script>
</body>
</html>